#include "nbody.h"
#include <ctype.h>

#define VALUE_ERROR  0
#define NAME_ERROR   1
#define NAME_WARNING 2
#define EMPTY_ERROR  3
#define FMT_ERROR    4

#define CTX_GLOBAL 0
#define CTX_UNSPEC 1
#define CTX_SIM    2
#define CTX_IO     3
#define CTX_GEN    4
#define CTX_GENOBJ 5

// helper index functions (since particles in y[] are indexed x, y, z, m)
int l_i(int i, int pos) {
  return 4*i + pos - 4;
}
// in y[] where x, x*, y, y*, z, z*, m
int rk_i(int i, int pos) {
  return 7*i + pos - 7;
}

// convert a list of particle to the l/dl format
void pt_to_l(PARTICLE *pts, int n, double *l, double *dl) {
  int i;
  for(i=1; i<=n; i++) {
    //pt[i-1]
    l[l_i(i, 1)] = pts[i-1].pos[0];
    l[l_i(i, 2)] = pts[i-1].pos[1];
    l[l_i(i, 3)] = pts[i-1].pos[2];
    l[l_i(i, 4)] = pts[i-1].mass;

    dl[l_i(i, 1)] = pts[i-1].vel[0];
    dl[l_i(i, 2)] = pts[i-1].vel[1];
    dl[l_i(i, 3)] = pts[i-1].vel[2];
    dl[l_i(i, 4)] = 0.0;
  }
}

void l_to_pt(double *l, double *dl, int n, PARTICLE *pts) {
  int i;
  static int id = 0;
  for(i=1; i<=n; i++) {
    pts[i-1].pos[0] = l[l_i(i, 1)];
    pts[i-1].pos[1] = l[l_i(i, 2)];
    pts[i-1].pos[2] = l[l_i(i, 3)];
    pts[i-1].mass = l[l_i(i, 4)];

    pts[i-1].vel[0] = dl[l_i(i, 1)];
    pts[i-1].vel[1] = dl[l_i(i, 2)];
    pts[i-1].vel[2] = dl[l_i(i, 3)];

    pts[i-1].id = id++;
  }
}

// right trim function
char *rtrim(char *str) {
  char *back = str + strlen(str);
  while(isspace(*--back));
  *(back+1) = '\0';
  return str;
}

// left trim function
char *ltrim(char *str) {
  while(isspace(*str)) str++;
  return str;
}

// trim function
char *trim(char *str) {
  return rtrim(ltrim(str));
}

// reader function for line counting
int points_from_file(FILE *fp, unsigned int flags) {
  if(flags & DEBUG) printf("nbody_util.points_from_file\n");
  int k;
  rewind(fp);
  if(flags & DEBUG) printf("nbody_util.points_from_file@beginning_scan\n");
  // k will equal number of points
  for(k = 0; fscanf(fp, "%*f %*f %*f %*f %*f %*f %*f") != EOF; k++);
  if(!k) {
    printf("points_from_file error: file could not be read properly\n");
    exit(1);
  }
  if(flags & DEBUG) printf("nbody_util.points_from_file@end_scan\n");
  return k;
}

// reader function
void state_from_file(FILE *fp, int *n, unsigned int flags, double *d[], double l[],
		     double dl[], double u[]) {
  int k;
  rewind(fp);
  // reading when leapfrog vectors are provided
  if(l) {
    for(k = 1; k <= (*n); k++) {
      fscanf(fp, "%lf %lf %lf %lf %lf %lf %lf\n", &l[l_i(k,4)], &l[l_i(k,1)],
	     &l[l_i(k,2)], &l[l_i(k,3)], &dl[l_i(k,1)], &dl[l_i(k,2)],
	     &dl[l_i(k,3)]);
      if(flags & DEBUG) printf("nbody_util.state_from_file->l_loop [%d]\n", k);
      if(flags & DEBUG) printf("point read: x y z - %lf %lf %lf\n", l[l_i(k,1)],
			       l[l_i(k,2)], l[l_i(k,3)]);
      dl[l_i(k,4)] = 0.0;
    }
  } else if(u) {
    // reading when rk4 vectors are provided
    for(k = 1; k <= (*n); k++) fscanf(fp, "%lf %lf %lf %lf %lf %lf %lf\n", &u[rk_i(k,7)],
				   &u[rk_i(k,1)], &u[rk_i(k,3)], &u[rk_i(k,5)],
				   &u[rk_i(k,2)], &u[rk_i(k,4)], &u[rk_i(k,6)]);
  } else if (d) {
    // reading when a data matrix is provided
    for(k = 1; fscanf(fp, "%lf %lf %lf %lf %lf %lf %lf\n", &d[1][k], &d[2][k], &d[3][k],
		      &d[4][k], &d[5][k], &d[6][k], &d[7][k]) != EOF; k++);
    (*n) = k-1;
  } else {
    printf("state_from_file error: no arrays initialized\n");
  }
}

// options reading file function
void opts_from_file(FILE *fp, unsigned int *flags, double *soft, double *ecc, char *f_in,
		    double *h, int *out_f, char **d_out, char *f_out, int *steps) {
  rewind(fp);
  int l_len = 128;
  char pt_l_buff[l_len];
  char l_buff[l_len];
  char *tkn;
  int k = 0;
  int ctx = 0; // context; 0 is global, 1 is unspec local, 2 is simulator, 3 is I/O,
  // 4 is generator, 5 is generator object
  const char del[2] = ":";

  if(*flags & DEBUG) printf("Beginning file loop...\n");
  
  while(fgets(pt_l_buff, l_len, fp)) {
    k++;

    // error if still in a context with an @ group declaration
    if( ctx && (pt_l_buff[0] == '@') ) {
      raise_error(FMT_ERROR, NULL, NULL, "missing closing bracket\n", k);
      continue;
    }
    // close context if an end of group detected
    if( ctx && (pt_l_buff[0]=='}') ) {
      ctx = 0;
      continue;
    }

    if(ctx) strcpy(l_buff, trim(pt_l_buff));
    else strcpy(l_buff, trim(pt_l_buff));
    
    switch(ctx) {
    case CTX_GLOBAL:
      // global context, skip non-@ led lines
      if(l_buff[0] != '@') continue;
      
      // global context, processing a group
      if(*flags & DEBUG) printf("Found group key...\n");
      if(l_buff[strlen(l_buff)-1] == '{') {
	ctx++;
	char parent[32];
	sscanf(l_buff, "@%[^{]", parent);
	if(*flags & DEBUG) printf("Read parent: %s\n", parent);

	if(!strcmp(parent, "SIM")) ctx = CTX_SIM;
	if(!strcmp(parent, "IO")) ctx = CTX_IO;
	if(!strcmp(parent, "GEN")) ctx = CTX_GEN;
	if(!strcmp(parent, "GAL")) ctx = CTX_GENOBJ;
	if(ctx==CTX_UNSPEC) raise_error(NAME_WARNING, parent, NULL, NULL, k);
	continue;
      }
      break;
    case CTX_UNSPEC:
      
      break;
    case CTX_SIM:
      tkn = strtok(l_buff, del);
      if(*flags & DEBUG) printf("tkn: %s\n", tkn);
      if(!strcmp(tkn, "softening")) {
	*soft = (double) atof(strtok(NULL, del));
	if(*flags & DEBUG) printf("Set value of softening to %f\n", *soft);
	continue;
      }
      if(!strcmp(tkn, "stepsize")) {
	*h = (double) atof(strtok(NULL, del));
	if(*flags & DEBUG) printf("Set value of stepsize to %f\n", *h);
	continue;
      }
      if(!strcmp(tkn, "steps")) {
	*steps = (int) atoi(strtok(NULL, del));
	if(*flags & DEBUG) printf("Set value of steps to %d\n", *steps);
	continue;
      }
      if(!strcmp(tkn, "bh_mode")) {
	if(atoi(strtok(NULL, del))) *flags |= MODE_BH;
	if((*flags & DEBUG) && (*flags & READ_FILE)) printf("Set to Barnes-Hutt mode\n");
	continue;
      }
      raise_error(NAME_WARNING, "SIM", tkn, NULL, k);
      break;
    case CTX_IO:
      tkn = strtok(l_buff, del);
      if(!strcmp(tkn, "file_in")) {
        f_in = strtok(NULL, del);
	if(strcmp(f_in, "none")) *flags |= READ_FILE;
	if((*flags & DEBUG) && (*flags & READ_FILE)) printf("Set value of f_in to '%s'\n",
						f_in);
	continue;
      }
      if(!strcmp(tkn, "file_out")) {
	f_out = strtok(NULL, del);
	if(strcmp(f_out, "none")) *flags |= PRINT_FILE;
	if((*flags & DEBUG) && (*flags & PRINT_FILE)) printf("Set value of f_out to '%s'\n",
						 f_out);
	continue;
      }
      if(!strcmp(tkn, "dir_out")) {
	char *out_tmp;
	out_tmp = strtok(NULL, del);
	*d_out = malloc(strlen(out_tmp)+1);
	strcpy(*d_out, out_tmp);
	if(strcmp(*d_out, "none")) *flags |= PRINT_DIR;
	if((*flags & DEBUG) && (*flags & PRINT_DIR)) printf("Set value of d_out to '%s'\n",
						*d_out);
	continue;
      }
      if(!strcmp(tkn, "console")) {
	if(!atoi(strtok(NULL, del))) *flags ^= PRINT_CONS;
	if((*flags & DEBUG) && !(*flags & PRINT_CONS)) printf("Set to not print to console\n");
	continue;
      }
      if(!strcmp(tkn, "out_freq")) {
	*out_f = atoi(strtok(NULL, del));
	if(*flags & DEBUG) printf("Set value of out_f to %d\n", *out_f);
	continue;
      }
      raise_error(NAME_WARNING, "IO", tkn, NULL, k);
      break;
    case CTX_GEN:
      tkn = strtok(l_buff, del);
      if(!strcmp(tkn, "mode")) {
	tkn = strtok(NULL, del);
	if(!strcmp(tkn, "2body")) *flags ^= (GEN_2BODY ^ (*flags & MODE_GROUP));
	else if(!strcmp(tkn, "sphere")) *flags ^= (GEN_SPHERE ^ (*flags & MODE_GROUP));
	else raise_error(VALUE_ERROR, "GEN", "mode", tkn, k);
	continue;
      }
      if(!strcmp(tkn, "objs")) {
	continue;
      }
      if(!strcmp(tkn, "mass")) {
	tkn = strtok(NULL, del);
	if(!strcmp(tkn, "uniform")) *flags ^= (MASS_NORM ^ (*flags & MASS_GROUP));
	else if(!strcmp(tkn, "rayleigh")) *flags ^= (MASS_RAY ^ (*flags & MASS_GROUP));
	else if(!strcmp(tkn, "uniform random")) *flags ^= (MASS_UNI ^ (*flags & MASS_GROUP));
	else raise_error(VALUE_ERROR, "GEN", "mass", tkn, k); 
	continue;
      }
      raise_error(NAME_WARNING, "GEN", tkn, NULL, k);
      break;
    case CTX_GENOBJ:
      tkn = strtok(l_buff, del);
      
      raise_error(NAME_WARNING, "GENOBJ", tkn, NULL, k);
      break;
    }
  }
}

// opts helpers
void raise_error(unsigned short type, char *parent, char *param, char *val, int ln) {
  switch(type) {
  case VALUE_ERROR:
    printf("Options file error [line: %d]: %s does not allow value %s\n", ln,
	   param, val);
    exit(1);
  case NAME_ERROR:
    printf("Options file error:\n");
    exit(1);
  case NAME_WARNING:
    if(param) printf("Options file warning [line %d]: '%s' of group '%s' is unrecognized\n",
		     ln, param, parent);
    else printf("Options file warning [line: %d]: '%s' is an uncrecognized group\n", ln,
	   parent);
    break;
  case EMPTY_ERROR:
    if(param) printf("Options file error: %s of group %s expects a value\n",
		     param, parent);
    else printf("Options file error: group %s is empty or not found\n", parent);
    exit(1);
  case FMT_ERROR:
    printf("Options file error [line %d]: %s\n", ln, val);
    exit(1);
  }
}
